# 3장 고급 타입

## 1. 타입스크립트만의 독자적 타입 시스템

타입스크립트에만 존재하는 독자적인 타입 시스템이지만 이 개념은 자바스크립트에 기인하였다.

### any 타입

> 자바스크립트에 존재하는 모든 값을 오류 없이 받을 수 있다.
> ➡️ 타입을 명시하지 않은 것과 동일한 효과

```ts
let state: any;

state = { value: 0 }; // 객체를 할당 👌
state = 0; // 숫자 할당 👌
state = 'Hello!'; // 문자열 할당 👌
state.foo.bar = () => console.log('Any'); // 심지어 중첩 구조로 들어가 함수를 할당해도 👌
```

결국 any 타입은 정적 타이핑을 적용하고자 하는 타입스크립트의 주된 목적과는 다르게 자바스크립트의 동적 타이핑으로 돌아가게 되는 결과를 가져온다!<br>
➡️ 그러므로 any 타입을 변수에 할당하는 것을 지양하자!

#### any 타입을 어쩔 수 없이 사용해야 하는 경우

- 개발 단계에서 임시로 값을 지정해야 할 때
  그러나 any 타입을 남발하게 되면 타입 안정성을 저해할 수 있다.
- 어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을 때
  (ex) API 요청 및 응답처리, 콜백 함수 전달, 타입아ㅣ 잘 정제되지 않아 파악히 힘든 외부 라이브러리 등을 사용할 때
- 값을 예측할 수 없을 때 암묵적으로 사용
  (ex) 외부 라이브러리나 웹 API의 요청에 따라 다양한 값을 반환하는 API를 이용하는 경우

### unknown 타입

> 모든 타입의 값이 할당될 수 있으나 **any를 제외한 다른 타입으로 선언된 변수에는 unknown 타입 값을 할당할 수 없다**!

```ts
let unknownValue: unknown;

unknownValue = 100; // 숫자 👌
unknownValue = 'unknown은 문자열도 가능'; // 문자열 👌
unknownValue = () => console.log('함수도 가능! 하지만');

let someValue1: any = unknownValue; // any 타입으로 선언된 변수를 제외한 다른 변수는 모두 할당 불가
let someValue2: number = unknownValue; // ❌
let someValue2: string = unknownValue; // ❌
```

**any랑 비슷한데 왜 unknown이 추가된걸까?**
<br>
➡️ unknown 타입 변수에 함수를 할당하면 컴파일러가 아무 경고를 주지 않지만 실행하면 에러가 발생한다. 이는, unknown 타입으로 선언된 변수는 어떤 값이든 올 수 있음을 의미하는 동시에 **개발자에게 엄격한 타입 검사를 강제**하는 의도가 담겨있다.

### void 타입

> 함수 타입을 지정할 때 아무런 값을 반환하지 않는 경우(변수에도 할당 가능하지나 의미 ❌)
> _자바스크립트와 다르게 undefined를 반환하는 것이 아님!_

- void 타입으로 지정된 변수는 undefined 또는 null 값만 할당 가능(null의 경우에는 tsconfig.json에서 strictNull-Checks 비활성화인 경우만 가능)
- 일반적으로 함수 자체를 다른 함수의 인자로 전달하는 경우가 아니라면 void 타입은 잘 명시하지 않음

### never 타입

> 값을 반환할 수 없는 타입으로 함수와 관련하여 많이 사용됨

자바스크립트에서 값을 반환할 수 없는 예

- 에러를 던지는 경우: throw 키워드 사용 시 에러 발생시키는데 이는 값을 반환하는 것으로 간주하지 않음 ➡️ 따라서 never 타입
- 무한히 함수가 실행되는 경우: 함수가 종료되지 않아 값을 반환하지 못함

### Array 타입

이미 자바스크립트에서도 Object.prototype.toString.call(...)연산자로 확인 가능한데 왜...?

- 자바스크립트에서는 배열이 객체에 속하는 타입으로 분류됨
- 타입스크립트에서 Array 타입을 사용하기 위해서는 TS의 특수한 문법을 함께 다뤄야 함

> 타입스크립트에서는 명시적인 타입을 선언하여 **타입의 원소를 관리**하는 것을 강제한다. ➡️ 배열 길이까지는 제한할 수 없음
>
> ```ts
> const array: Array<number> = [1, 2, 3]; // number[]와 동일한 타입 선언 -> 차이 없음
> const array1: Array<number | string> = [1, 'string'];
> ```

<br>

cf) 튜플

- 타입스크립트의 타입 시스템과 대괄호를 사용해서 선언 가능
- 배열의 특정 인덱스에 정해진 타입을 선언하는 것
  ```ts
  let tuple: [number, string, boolean] = [1, 'A', true]; // 여러 타입과 혼합 가능
  ```
- 자바스크립트와 다르게 제한적으로 사용됨
- 배열의 길이까지 제한하여 원소 개수와 타입을 보장
- (ex) 리액틔의 useState는 튜플 타입을 반환함

### enum 타입

> 열거형, 구조체를 만드는 타입 시스템
>
> ```ts
> enum ProgrammingLanguage {
>   TypeScript, // 0
>   JavaScript, // 1
>   Java, // 2
>   Python, // 3
>   Kotlin, //4
>   Rust, // 5
>   Go, // 6
> }
> // 각 멤버에게 접근하는 방식은 자바스크립트에서 객체의 속성에 접근하는 방식과 동일
> ProgrammingLanguage.TypeScript; // 0
> ProgrammingLanguage['Go']; // 6
> ProgrammingLanguage[2]; // "Java"
> ```

- 주로 문자열 상수를 생성하는 데 사용됨

  ```ts
  enum ItemStatusType {
    DELIVERY_HOLD = 'DELIVERY_HOLD', // 배송 보류
    DELIVERY_READY = 'DELIVERY_READY', // 배송 준비 중
    DELIVERING = 'DELIVERING', // 배송 중
    DELIVERED = 'DELIVERED', // 배송 완료
  }

  const checkItemAvailable = (itemStatus: ItemStatusType) => {
    switch (itemStatus) {
      case ItemStatusType.DELIVERY_HOLD:
      case ItemStatusType.DELIVERY_READY:
      case ItemStatusType.DELIVERING:
        return false;
      case ItemStatusType.DELIVERED:
      default:
        return true;
    }
  };
  ```

  그냥 문자열 타입을 지정한 것과 비교했을 때 효과

  - 타입 안정성
  - 명확한 의미 전달과 높은 응집력
  - 가독성

- 숫자로만 이루어져 있거나 타입스크립트가 자동으로 추론한 열거형은 안전하지 않은 결과를 나을 수 있음(할당된 값을 넘어서는 범위로 역방향으로 접근하더라도 타입스크립트는 막지 않음) ➡️ `const enum`으로 열거형을 선언하기도(역방향 접근 허용 X), 그러나 숫자 상수로 관리되는 열거형은 선언한 값 이외의 값을 할당하거나 접근할 때 이를 방지하지 못함
- 열거형은 불필요한 코드 크기가 증가하는 결과가 나타날수도...

## 2. 타입 조합

### 교차 타입(Intersection)

> 여러 가지 타입을 결합하여 하나의 단일 타입으로 만들 수 있음

- &를 사용하여 표기함
- 단일 타입에는 타입 별칭을 붙일 수도 있음

```ts
type ProductItem = {
  id: number;
  name: string;
  type: string;
  price: number;
  imageUrl: string;
  quantity: number;
};

// 교차타입
type ProductItemWithDiscount = ProductItem & { discountAcount: number };
```

### 유니온 타입(Union)
> 